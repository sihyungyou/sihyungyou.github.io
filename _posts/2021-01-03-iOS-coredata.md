---
layout: post
title: "코어데이터 다시보기"
tags: [iOS]
comments: true
---

> 코어데이터  

⚠ iOS알못의 글이므로 틀린 정보가 있을 수 있습니다.  

## 코어데이터란?

코어데이터는 애플의 `local object graph persistence framework`로 로컬 디바이스에 데이터를 저장하는 목적으로 사용된다.

보통 앱이 실행되는 동안 메모리에 올라가는 데이터들은 앱을 종료하거나 리부트시키면 모두 초기화되어 다시 처음부터 데이터를 쌓아야한다. 이런 휘발성을 방지하고자 앱 자체에 데이터를 저장했었는데 바로 `UserDefault` 였다. 하지만 이 역시 영구적으로 데이터를 저장하지는 못한다. (이 때 앱을 종료한다는 것은 단순히 홈 버튼을 눌러서 background로 빠지는 것이 아니라 앱 스위쳐에서 위로 스와이프해서 앱을 죽이는 것을 의미한다) 또한 UserDefault는 app setting 같은 간단한 정보를 저장하기에 적합하다면 코어데이터는 복잡하고 큰 user data를 저장하기에 적합하다.

앱을 종료하거나 리부트, 심지어는 디바이스를 재시동 했을 때도 앱 실행중에 사용하던 데이터를 영구적으로(persistently) 데이터를 디스크에(on-disk) 저장해두고 불러올 수 있도록 하는 것이 코어데이터이다.

아래 사진을 보면 왜 위에서 객채 그래프(object graph) 라는 용어가 나왔는지 알 수 있다. 메모리에 객체들이 여러 relationship으로 엮여있는 것을 객체 그래프라고 하고, 이 형태를 그대로 코어데이터의 컨테이너에 저장시키기 때문이다.

![1](https://user-images.githubusercontent.com/35067611/104593159-9e9a1e80-56b2-11eb-9999-ff76c02e93b7.png)

## 코어데이터는 데이터베이스인가?

결론부터 말하자면 "아니다" 코어데이터는 정확히 말하자면 ORM 매핑 Framework, 즉 데이터 저장에 관한 일종의 프레임워크이다. 그리고 코어데이터의 기능 중 하나인 Persistence는 관계형 데이터베이스인 SQLite에 의해 지원된다. 즉, Persistence는 코어데이터의 기능 중 하나일 뿐 Core Data == Database는 아니다. Persistence 기능을 사용하지 않고도 코어데이터를 사용할 수 있기 때문이다.

다시 정리하자면 **코어데이터는 애플리케이션의 모델 계층의 객체를 관리하는데 사용하는** `프레임워크`**이자 객체의 라이프 사이클이나 영속성 관리를 위한 기능을 제공하는** `객체 그래프 관리자`이다. "객체 그래프"라는 단어에서 알 수 있듯 외부에서 보기에는 Object-Oriented Database의 형태를 띄고 있지만 그 내부에는 SQLite Database처럼 기능하고있다. (XML Store Type, In-Memory Store Type도 있다. SQLite은 그 중 하나일 뿐)

## 코어데이터의 구성

![2](https://user-images.githubusercontent.com/35067611/104593177-a3f76900-56b2-11eb-9285-74974b875357.png)

**1) 관리 객체(Managed Obejct) : NSManagedObject**

테이블에서 레코드를 읽을 때 코어데이터에서는 객체가 생성되는데, 이 객체를 저장하는 자료형

예) 직원들의 데이터를 다룰 때 DB에서 직원들의 정보를 읽어오면 이것을 그대로 사용하지 않고 VO(Value Object)인스턴스에 담아 사용, 이때 VO가 관리 객체에 해당

**2) 관리 객체 컨텍스트(Managed Object Context)**

핵심적인 두 가지 역할

(1) MO를 가지고 CRUD역할 (Core Data에서 생성되는 모든 관리 객체는 컨텍스트에 담겨 관리)

- 컨텍스트에 담긴 객체는 영구 저장소로 보내 저장, 삭제 가능

- 코더데이터는 메모리에 로드된 상태로 처리되는데, 이 때의 메모리가 "컨텍스트"를 의미

(2) "영구 저장소"와 "영구 저장소 코디네이터"에 대한 관리자 역할

- 읽기와 쓰기를 영구 저장소에 요청 (DAO패턴과 유사)

**3) 영구 저장소 코디네이터(Persistent Store Coordinator)**

컨텍스트와 직접 데이터를 주고 받으면서 다양한 영구 저장소들의 접근을 조정하고 입출력을 담당

흐름 : 컨텍스트가 데이터 요청 -> 코디네이터가 요청을 받고, 영구 저장소에서 데이터 탐색 -> 코디 네이터가 MO인스턴스 생성하여 반환

**4) 관리 객체 모델(Managed Obejct Model)**

엔터티(Entity)의 구조를 정의하는 객체인 동시에 이를 바탕으로 MO패턴의 모델 클래스를 참조

※ MO vs MOM(Managed Object Model)

- MOM : 클래스이자 형식이고 구조를 의미, 데이터를 CRUD하지 않으며 관리 객체의 각 요소를 제대로 담을 수 있도록 저장 데이터를 구조화

- MO : MOM을 바탕으로 생성된 인스턴스

**5) 영구 객체 저장소(Persistent Obejct Store)**

초기에는 직접 읽을 수 있으며 디버깅에 용이한 XML저장소 타입을 사용하며, 앱을 배포할 당시 대량의 데이터를 고려하여 SQLite데이터베이스를 사용하는 것이 용이

## 한계

**1) in-memory방식 : 메모리에 로딩된 객체에 대해서만 수정 가능(SQLite는 메모리에 객체 모두를 로딩하지 않아도, 최소한의 데이터만 로드)**

in-memory에서 데이터 삭제시, 영구저장소에서 데이터 read -> 객체로 생성 -> 이것을 메모리에 로딩 -> 이를 삭제하고 다시 컨텍스트를 저장소에 커밋

**2) 데이터 로직에서의 한계**

- 중복된 값의 입력을 방지하는 "Unique"키가 없으므로, 애플리케이션에서 비즈니스 로직을 통해 처리해야 가능

**3) thread-safe하지 않음(싱글스레드 환경)**

thread끼리 Lock기능(다른 쓰레드가 침범하지 못하는 것)이 존재하지 않음(단 락을 걸지 않음으로써 빠르게 데이터 처리가 가능)

* SQLite역시 싱글 스레드만 지원

## References

[Core Data (1)](https://zeddios.tistory.com/987)

[[iOS - swift] 12. 코어 데이터(Core Data)의 개념 - (1)](https://ios-development.tistory.com/89)

---
layout: post
title: "코드포스 R656 (2 Solved)"
tags: [알고리즘, 코드포스]
comments: true
---

> CodeForces  

### [A번 링크](https://codeforces.com/contest/1385/problem/A)  

### 접근  
- 세 수가 모두 같거나 적어도 한 쌍이 같고 마지막 수가 쌍을 이루는 수보다 작거나 같아야한다. 그 외의 경우는 NO를 출력한다.  
- 위 조건을 만족했다면 a = min(x, y), b = min(x, z), c = min(y, z)이다.  

### 코드  
~~~c++
#include <cstdio>
#include <algorithm>

using namespace std;

int main() {

    int t;
    scanf("%d", &t);

    while(t--) {
        int x, y, z, a, b, c;
        scanf("%d %d %d", &x, &y, &z);

        if ( (x != y && x != z && y != z) || (x == y && y < z) || (x == z && z < y) || (y == z && z < x)) {
            printf("NO\n");
            continue;
        }
        if (x == y && y == z) {
            printf("YES\n");
            printf("%d %d %d\n", x, y, z);
        } else {
            a = min(x, y);
            b = min(x, z);
            c = min(y, z);
            printf("YES\n");
            printf("%d %d %d\n", a, b, c);
        }
    }
    return 0;
}
~~~

### [B번 링크](https://codeforces.com/contest/1385/problem/B)  

### 접근  
- 배열 a를 순회하면서 한번이라도 나온 수는 visit에 체크해두고 p 배열에 추가한다.  
- 위 과정을 반복하되 visit 배열에 방문함이 체크되어있다면 p 배열에 추가하지 않는다.  
- 이렇게 함으로써 a 배열에 들어있는 모든 수를 한번씩만 p 배열로 옮기되, 그 순서를 보존할 수 있다.  

### 코드  
~~~c++
#include <cstdio>
#include <cstring>

using namespace std;

int main() {

    int t;
    scanf("%d", &t);

    while(t--) {
        int n;
        scanf("%d", &n);

        bool visit[n + 1];
        int a[2 * n];
        int p[n];

        memset(visit, false, sizeof(visit));
        for (int i = 0; i < 2*n; i++) {
            scanf("%d", &a[i]);
        }

        int j = 0;
        for (int i = 0; i < 2 * n; i++) {
            if (!visit[a[i]]) {
                p[j++] = a[i];
                visit[a[i]] = true;
            }
        }

        for (int i = 0; i < n; i++) {
            printf("%d ", p[i]);
        }
        printf("\n");
    }

    return 0;
}
~~~

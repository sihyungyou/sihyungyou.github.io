---
layout: post
title: "Codeforces Round #653"
tags: [ì•Œê³ ë¦¬ì¦˜, ëŒ€íšŒ, ì½”ë“œí¬ìŠ¤]
comments: true
---

> 2020/06/28  

### A. Required Remainder  
time limit per test : 1 second  
memory limit per test : 256 megabytes  

You are given three integers ğ‘¥,ğ‘¦ and ğ‘›. Your task is to find the maximum integer ğ‘˜ such that 0â‰¤ğ‘˜â‰¤ğ‘› that ğ‘˜modğ‘¥=ğ‘¦, where mod is modulo operation. Many programming languages use percent operator % to implement it.  

In other words, with given ğ‘¥,ğ‘¦ and ğ‘› you need to find the maximum possible integer from 0 to ğ‘› that has the remainder ğ‘¦ modulo ğ‘¥.  

You have to answer ğ‘¡ independent test cases. It is guaranteed that such ğ‘˜ exists for each test case.  

Input  
The first line of the input contains one integer ğ‘¡ (1â‰¤ğ‘¡â‰¤5â‹…104) â€” the number of test cases. The next ğ‘¡ lines contain test cases.  

The only line of the test case contains three integers ğ‘¥,ğ‘¦ and ğ‘› (2â‰¤ğ‘¥â‰¤109; 0â‰¤ğ‘¦<ğ‘¥; ğ‘¦â‰¤ğ‘›â‰¤109).  

It can be shown that such ğ‘˜ always exists under the given constraints.  

Output  
For each test case, print the answer â€” maximum non-negative integer ğ‘˜ such that 0â‰¤ğ‘˜â‰¤ğ‘› and ğ‘˜modğ‘¥=ğ‘¦. It is guaranteed that the answer always exists.  

### ì ‘ê·¼  
0ë¶€í„° nê¹Œì§€ì˜ ìˆ˜ ì¤‘ k % x = y ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìµœëŒ€ê°’ kë¥¼ ì°¾ìœ¼ë©´ ëœë‹¤. nì„ xë¡œ ë‚˜ëˆ„ì—ˆì„ ë•Œ ëª«ì„ q, ë‚˜ë¨¸ì§€ë¥¼ rì´ë¼ê³  í•˜ì. r == y ë¼ë©´ ì´ ë•Œì˜ nì´ kì´ë‹¤. r < y ë¼ë©´ ë§Œì¡±ì‹œí‚¤ë ¤ëŠ” ê°’ë³´ë‹¤ ë‚˜ë¨¸ì§€ê°€ ì‘ìœ¼ë¯€ë¡œ ëª«ì´ í¬ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. ê·¸ëŸ¬ë¯€ë¡œ k = q-1 * x + yê°€ ë‹µì´ ëœë‹¤.  

### ì½”ë“œ  
~~~c++
#include <cstdio>
using namespace std;

int main () {

    int x, y, n, k, t, i;

    scanf("%d", &t);
    for (i = 0; i < t; i++) {
        scanf("%d %d %d", &x, &y, &n);
        int q = n / x;
        int r = n % x;
        if (r == y) k = n;
        else if (r > y) k = x * q + y;
        else if (r < y) k = x * (q-1) + y;
        printf("%d\n", k);
    }

    return 0;
}
~~~

### B. Multiply by 2, divide by 6  
time limit per test : 1 second  
memory limit per test : 256 megabytes  

You are given an integer ğ‘›. In one move, you can either multiply ğ‘› by two or divide ğ‘› by 6 (if it is divisible by 6 without the remainder).  

Your task is to find the minimum number of moves needed to obtain 1 from ğ‘› or determine if it's impossible to do that.  

You have to answer ğ‘¡ independent test cases.  

Input  
The first line of the input contains one integer ğ‘¡ (1â‰¤ğ‘¡â‰¤2â‹…104) â€” the number of test cases. Then ğ‘¡ test cases follow.  

The only line of the test case contains one integer ğ‘› (1â‰¤ğ‘›â‰¤109).  

Output  
For each test case, print the answer â€” the minimum number of moves needed to obtain 1 from ğ‘› if it's possible to do that or -1 if it's impossible to obtain 1 from ğ‘›.  

### ì ‘ê·¼  
6ìœ¼ë¡œ ë‚˜ëˆ„ì–´ì§€ì§€ ì•ŠëŠ”ë‹¤ë©´ 2ë¥¼ ê³±í•˜ëŠ” ê³¼ì •ì„ ë°˜ë³µí•˜ë˜ ìµœëŒ€ê°’ì„ ë„˜ì–´ì„œë©´ ë¶ˆê°€ëŠ¥í•œ ê²ƒìœ¼ë¡œ íŒë‹¨í•œë‹¤.  

### ì½”ë“œ  
~~~c++
#include <cstdio>
using namespace std;

#define MAX 1000000000

int main () {
    int t, i, n, ans;

    scanf("%d", &t);
    for (i = 0; i < t; i++) {
        scanf("%d", &n);

        ans = 0;
        while(1) {
            if (n == 1) {
                break;
            }
            else if (n > MAX) {
                ans = -1;
                break;
            }
            else if (n % 6 == 0) {
                n /= 6;
                ans++;
            }
            else {
                n *= 2;
                ans++;
            }
        }
        printf("%d\n", ans);
    }

    return 0;
}
~~~

---
layout: post
title: "Software Testing Study CH 2-4"
tags: [Software Testing, Fuzzing, ê³µë¶€]
comments: true
---

> Greybox Fuzzing

ì´ì „ ì¥ê¹Œì§€ Basic fuzzing, coverage, mutation-based fuzzingì— ëŒ€í•´ì„œ ë‹¤ë£¨ì—ˆë‹¤. ì´ë²ˆ ì¥ë¶€í„°ëŠ” ì´ mutationsë¥¼ ì–´ë–»ê²Œ íŠ¹ì •í•œ ëª©í‘œë¡œ ì´ëŒì–´ê°€ëŠ”ì§€ì— ëŒ€í•´ì„œ ì´ì•¼ê¸°í•œë‹¤. American Fuzzy Lop(ALF)ì˜ ì•Œê³ ë¦¬ì¦˜ì„ ì°¨ìš©í•˜ì—¬ ë°ëª¨ ì‹¤ìŠµì´ ê°€ëŠ¥í•˜ë‹¤. 

### Ingredients for Greybox Fuzzing

1. Background  

AFLì€ mutation-based fuzzerì´ë‹¤. ì¦‰, seed inputì„ ì¡°ê¸ˆì”© ë°”ê¾¸ê±°ë‚˜ ë‘ ê°œì˜ ë‹¤ë¥¸ inputì„ í•©ì³ì„œ ìƒˆë¡œìš´ ë¬¸ìì—´ì„ ë§Œë“ ë‹¤ëŠ” ëœ»ì´ë‹¤. AFLì€ ë˜í•œ greybox fuzzer ì¸ë° coverage-feedbackì„ í†µí•´ í”„ë¡œê·¸ë¨ì— ì–´ë–»ê²Œ ë” ê¹Šì´ reach í•  ì§€ ë°°ìš°ê¸° ë•Œë¬¸ì´ë‹¤. AFLì€ ì™„ì „í•œ black-boxë„, white-boxë„ ì•„ë‹ˆë‹¤. ì „ìê°€ ì•„ë‹Œ ì´ìœ ëŠ” í”„ë¡œê·¸ë¨ ë¶„ì„ì„ ì¡°ê¸ˆì´ë¼ë„ ì´ìš©í•˜ê¸° ë•Œë¬¸ì´ë‹¤. í›„ìì˜ ê²½ìš°ëŠ” AFLì´ ì‹¬ë„ìˆëŠ” í”„ë¡œê·¸ë¨ ë¶„ì„ì„ ê¸°ë°˜ìœ¼ë¡œ ì‘ë™í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì´ë‹¤. ëŒ€ì‹  generated inputì˜ coverage informationì„ ì£¼ì›Œëª¨ìœ¼ëŠ” ê°€ë²¼ìš´ ë°©ì‹ìœ¼ë¡œ ì‘ë™í•œë‹¤. ë§Œì•½ ìƒì„±ëœ ì…ë ¥ê°’ì´ coverageë¥¼ ì¦ê°€ì‹œí‚¨ë‹¤ë©´ ê·¸ê²ƒì€ í›„ì˜ fuzzingì„ ìœ„í•´ì„œ seed corpusì— ì¶”ê°€ëœë‹¤.  

2. Mutator and Seed  
mutator class implementationëŠ” insert, delete, flip ì„¸ ê°€ì§€ ê²½ìš°ì˜ mutation ë°©ì‹ í•¨ìˆ˜ë¥¼ í¬í•¨í•˜ê³  ìˆë‹¤. ì–´ë–¤ ë°©ë²•ìœ¼ë¡œ mutate í•  ê±´ì§€ë„ ëœë¤ìœ¼ë¡œ ì„ íƒëœë‹¤.  

3. Power Schedules  
Power scheduleì€ fuzzing timeì„ seeds ì‚¬ì´ì— ê· ë“±í•˜ê²Œ ë°°ë¶„í•˜ëŠ” ê°œë…ì´ë‹¤. ê·¸ëŸ¬ê¸° ìœ„í•´ì„œ seedsì—ì„œ inputì„ ì„ íƒí•´ì„œ ê°€ì ¸ì˜¬ ë•Œ seedâ€™s energy ê°’ì— ì˜ì¡´í•œë‹¤. fuzzingì´ ì§„í–‰ë˜ëŠ” ë™ì•ˆ ìš°ë¦¬ëŠ” ë” ê°€ëŠ¥ì„±ì´ ìˆëŠ” (ë” ì§§ì€ ë¬¸ìì—´, ë” ë¹ ë¥¸ ì‹¤í–‰ì†ë„, coverageë¥¼ ë” ìì£¼ ì¦ê°€ì‹œí‚¤ëŠ”) seedì— ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ë‘ê³  ì„ íƒí•œë‹¤. ê·¸ëŸ¬ë¯€ë¡œ seedëŠ” data ë¿ë§Œ ì•„ë‹ˆë¼ energy ê°’ë„ ê°€ì§„ë‹¤.  

~~~python
class PowerSchedule(object):    
    def assignEnergy(self, population):
        """Assigns each seed the same energy"""
        for seed in population:
            seed.energy = 1

    def normalizedEnergy(self, population):
        """Normalize energy"""
        energy = list(map(lambda seed: seed.energy, population))
        sum_energy = sum(energy)  # Add up all values in energy
        norm_energy = list(map(lambda nrg: nrg/sum_energy, energy))
        return norm_energy
    
    def choose(self, population):
        """Choose weighted by normalized energy."""
        import numpy as np

        self.assignEnergy(population)
        norm_energy = self.normalizedEnergy(population)
        seed = np.random.choice(population, p=norm_energy)
        return seed
~~~

~~~python
population = [Seed("A"), Seed("B"), Seed("C")]
schedule = PowerSchedule()
hits = {
    "A" : 0,
    "B" : 0,
    "C" : 0
}

for i in range(10000):
    seed = schedule.choose(population)
    hits[seed.data] += 1

hits
~~~

ê²°ê³¼  
~~~
{'A': 3372, 'B': 3319, 'C': 3309}
~~~


### Blackbox, Greybox, and Boosted Greybox Fuzzing

1. Blackbox Mutation-based Fuzzer  
mutator + power scheduleì˜ ê°œë…ì„ fuzzerì— í•©ì³ì„œ ë„£ì–´ë³´ì. ë¨¼ì € blackbox fuzzerë¡œ ì‹œì‘í•´ë³¼ ê²ƒì´ë‹¤.  
black box fuzzerì´ê¸° ë•Œë¬¸ì— ê¸°ë³¸ì ìœ¼ë¡œ coverage information leverageë¥¼ í•˜ì§€ ì•ŠëŠ”ë‹¤. fuzz í•¨ìˆ˜ëŠ” return generated input, run í•¨ìˆ˜ëŠ” executes fuzz specified number of timesë¥¼ ìˆ˜í–‰í•œë‹¤.  

MutationFuzzer classëŠ” initial seed, mutator, power scheduleë¡œ êµ¬ì„±ë˜ì–´ ìˆë‹¤. fuzzëŠ” ì•„ë˜ì˜ ë‘ ê°€ì§€ ê²½ìš°ë¡œ ì—­í• ì´ ë‚˜ë‰  ìˆ˜ ìˆë‹¤.   
- unfuzzed seed from the initial seeds  
- result of fuzzing a seed in the population  

í›„ìë¥¼ handle í•˜ëŠ” ê²ƒì´ create_candidate í•¨ìˆ˜ì´ë‹¤. populationìœ¼ë¡œ ë¶€í„° ì…ë ¥ê°’ì„ ëœë¤í•˜ê²Œ ì„ íƒí•´ì™€ mutationì„ ì ìš©í•˜ëŠ” ê²ƒì´ë‹¤.  

MutationFuzzer Class implementatoin  
~~~python
class MutationFuzzer(Fuzzer):
    
    def __init__(self, seeds, mutator, schedule):
        self.seeds = seeds
        self.mutator = mutator
        self.schedule = schedule
        self.inputs = []
        self.reset()

    def reset(self):
        """Reset the initial population and seed index"""
        self.population = list(map(lambda x: Seed(x), self.seeds))
        self.seed_index = 0

    def create_candidate(self):
        """Returns an input generated by fuzzing a seed in the population"""
        seed = self.schedule.choose(self.population)

        # Stacking: Apply multiple mutations to generate the candidate
        candidate = seed.data
        trials = min(len(candidate), 1 << random.randint(1,5))
        for i in range(trials):
            candidate = self.mutator.mutate(candidate)
        return candidate

    def fuzz(self):
        """Returns first each seed once and then generates new inputs"""
        if self.seed_index < len(self.seeds):
            # Still seeding
            self.inp = self.seeds[self.seed_index]
            self.seed_index += 1
        else:
            # Mutating
            self.inp = self.create_candidate()
            
        self.inputs.append(self.inp)
        return self.inp
    
~~~

Black box mutation-based fuzzerì˜ ì‘ë™ ë°©ì‹ì„ ìš”ì•½í•˜ë©´ "ì²˜ìŒì— ì œê³µë˜ëŠ” initial seeds setì„ fuzzingí•¨ìœ¼ë¡œì¨ ìƒˆë¡œìš´ ì…ë ¥ê°’ì„ ìƒì„±í•˜ë˜, ë‹¤ìŒ seedë¥¼ ì„ íƒí•  ë•ŒëŠ” power schedule ë°©ì‹ì„ ë„ì…í•˜ì—¬ ì„ íƒí•œë‹¤" ì´ë‹¤.  

2. Greybox Mutation-based Fuzzer  
Black-box fuzzerì™€ëŠ” ë°˜ëŒ€ë¡œ greybox fuzzerëŠ” coverage informationì„ í™œìš©í•œë‹¤. êµ¬ì²´ì ìœ¼ë¡œëŠ”, seed populationì— code coverageë¥¼ ì¦ê°€ì‹œí‚¤ëŠ” generated inputì„ ë”í•´ê°€ëŠ” ë°©ì‹ìœ¼
ë¡œ í™œìš©í•œë‹¤.  

~~~python
class GreyboxFuzzer(MutationFuzzer):    
    def reset(self):
        """Reset the initial population, seed index, coverage information"""
        super().reset()
        self.coverages_seen = set()
        self.population = [] # population is filled during greybox fuzzing
           
    def run(self, runner):
        """Run function(inp) while tracking coverage.
           If we reach new coverage,
           add inp to population and its coverage to population_coverage
        """
        result, outcome = super().run(runner)
        new_coverage = frozenset(runner.coverage())
        if new_coverage not in self.coverages_seen:
            # We have new coverage
            seed = Seed(self.inp)
            seed.coverage = runner.coverage()
            self.coverages_seen.add(new_coverage)
            self.population.append(seed)

        return (result, outcome)
~~~

greyboxfuzzer classì—ì„œ run í•¨ìˆ˜ëŠ” í•œ ë²ˆì˜ inputë§Œ ìƒì„±í•œë‹¤. ê·¸ë¦¬ê³  ìƒˆë¡œ ë°œê²¬ëœ coverage informationì´ ìˆë‹¤ë©´ seedë¥¼ ìƒì„±, populationì— ì¶”ê°€ í›„ coverageëŠ” seenìœ¼ë¡œ ì˜®ê²¨ë†“ëŠ”ë‹¤. ìœ„ì™€ ê°™ì€ ì•Œê³ ë¦¬ì¦˜ì€ Coverage-feedback ë¡œë¶€í„° ë§ì€ ë„ì›€ì„ ì–»ëŠ”ë‹¤. ìƒˆë¡œìš´ seedsë“¤ì€ fuzzerë¡œ í•˜ì—¬ê¸ˆ í”„ë¡œê·¸ë¨ì˜ ë” ê¹Šì€ ì½”ë“œ êµ¬ì—­ê¹Œì§€ ê°ˆ ìˆ˜ ìˆë„ë¡ ì•ˆë‚´í•˜ëŠ” ì—­í• ì„ í•˜ê²Œ ëœë‹¤.  
~~~python
reybox_fuzzer.population
~~~

ê²°ê³¼
~~~
[good, bood, baoo`N", baduoo`N", bad!uo`N"]
~~~

Greybox fuzzerì—ì„œ seedsë“¤ì´ ë” ë§ì€ í…ŒìŠ¤íŒ… ê³¼ì •ìœ¼ë¡œ fuzzerë¥¼ ê°€ì´ë“œí•´ì£¼ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆëŠ”ë°, ìœ„ì˜ ê²°ê³¼ëŠ” input goodì´ exceptionì„ ì¼ìœ¼í‚¤ëŠ” inputì¸ badë¡œ mutateë˜ëŠ” ê³¼ì •ì„ ë³´ì—¬ì¤€ë‹¤.

![Center example image](https://user-images.githubusercontent.com/35067611/61800448-fc57fc80-ae67-11e9-8214-344f93330adb.png "Center"){: .center-image}  

3. Boosted Greybox Fuzzer
Boosted greybox fuzzerëŠ” ë” ë§ì€ coverageë¥¼ ì•½ì†í•˜ëŠ” seedì—ê²Œ ë” ë§ì€ energyë¥¼ ì¤€ë‹¤. ì¦‰, power schedule ì•Œê³ ë¦¬ì¦˜ì„ ì‚´ì§ ë°”ê¾¸ëŠ” ê²ƒì´ë‹¤. generated inputì— ì˜í•´ì„œ ì ê²Œ exercise ë˜ëŠ” ì½”ë“œë¥¼ unusual paths ë¼ê³  í•˜ëŠ”ë°, ì´ unusual pathë¥¼ ë§ì´ exerciseí•˜ëŠ” seedê°€ ê·¸ê²ƒì´ë‹¤.  

~~~python
class AFLFastSchedule(PowerSchedule): 
    def __init__(self, exponent):
        self.exponent = exponent
            
    def assignEnergy(self, population):
        """Assign exponential energy inversely proportional to path frequency"""
        for seed in population:
            seed.energy = 1 / (self.path_frequency[getPathID(seed.coverage)] ** self.exponent)
~~~
ê¸°ì¡´ì˜ Power Scheduleì—ì„œ ê°€ì¤‘ì¹˜ë¥¼ ì¶”ê°€í•œ AFLFastSchedule ì½”ë“œ  

~~~python
class CountingGreyboxFuzzer(GreyboxFuzzer):
    def reset(self):
        """Reset path frequency"""
        super().reset()
        self.schedule.path_frequency = {}
    
    def run(self, runner):
        """Inform scheduler about path frequency"""
        result, outcome = super().run(runner)

        path_id = getPathID(runner.coverage())
        if not path_id in self.schedule.path_frequency:
            self.schedule.path_frequency[path_id] = 1
        else:
            self.schedule.path_frequency[path_id] += 1
            
        return(result, outcome)
~~~

ì¦‰, coverage informationì„ ìˆ˜ì§‘í•  ë•Œ ë§ˆë‹¤ frequencyë¥¼ ê¸°ë¡í•˜ê³  assignEnergyí•¨ìˆ˜ì—ì„œëŠ” ê·¸ frequency ê°’ì´ ì‘ì„ìˆ˜ë¡ (unusual path ì¼ìˆ˜ë¡) í° ê°€ì¤‘ì¹˜ë¥¼ ë¶€ì—¬í•´ì£¼ëŠ” ê²ƒ.  

ê¸°ì¡´ì˜ greybox fuzzerì™€ boosted greybox fuzzerì˜ seed energy ê²°ê³¼ë¥¼ í™•ì¸í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.  
~~~
'f2e66f5447cf94afc06f4aff3d7cf349', 0.25000, 'good'
'3e55dc120b76995e04fdeb76ef790af8', 0.25000, 'bgko?'
'e11bfcc84cfe5320d36a03abff4d8135', 0.25000, 'bao|oD?'
'ccab8793361783ff88e8cafc58ed178b', 0.25000, 'bado}oiD\x7f'
~~~
~~~
'f2e66f5447cf94afc06f4aff3d7cf349', 0.00000, 'good'
'3e55dc120b76995e04fdeb76ef790af8', 0.00000, 'bood/'
'e11bfcc84cfe5320d36a03abff4d8135', 0.00002, 'ba^noD\x0f'
'ccab8793361783ff88e8cafc58ed178b', 0.00173, 'bad\x0f'
'd5b7040bdd60ea92a98a0d715bdb7ced', 0.99825, 'bad!\x0e'
~~~

---
layout: post
title: "Codeforces Round #652"
tags: [ì•Œê³ ë¦¬ì¦˜, ëŒ€íšŒ, ì½”ë“œí¬ìŠ¤]
comments: true
---

> 2020/06/23  

### A. FashionabLee  
time limit per test : 2 seconds  
memory limit per test : 256 megabytes  

Lee is going to fashionably decorate his house for a party, using some regular convex polygons...  

Lee thinks a regular ğ‘›-sided (convex) polygon is beautiful if and only if he can rotate it in such a way that at least one of its edges is parallel to the ğ‘‚ğ‘‹-axis and at least one of its edges is parallel to the ğ‘‚ğ‘Œ-axis at the same time.  

Recall that a regular ğ‘›-sided polygon is a convex polygon with ğ‘› vertices such that all the edges and angles are equal.  

Now he is shopping: the market has ğ‘¡ regular polygons. For each of them print YES if it is beautiful and NO otherwise.  

Input  
The first line contains a single integer ğ‘¡ (1â‰¤ğ‘¡â‰¤104) â€” the number of polygons in the market.  

Each of the next ğ‘¡ lines contains a single integer ğ‘›ğ‘– (3â‰¤ğ‘›ğ‘–â‰¤109): it means that the ğ‘–-th polygon is a regular ğ‘›ğ‘–-sided polygon.  

Output  
For each polygon, print YES if it's beautiful or NO otherwise (case insensitive).  

### ì ‘ê·¼  
ì„¸ë¡œì¶•ê³¼ ê°€ë¡œì¶•ì— í‰í–‰í•œ í•œ ìŒì˜ ë³€ì´ ë°˜ë“œì‹œ ìˆëŠ” ì •ë‹¤ê°í˜•ì¸ì§€ êµ¬ë¶„í•˜ëŠ” ë¬¸ì œì´ë‹¤. ì´ëŸ¬í•œ ì¡°ê±´ì„ ë§Œì¡±í•˜ë ¤ë©´ ë³€ì˜ ê°œìˆ˜ nì´ 4ì˜ ë°°ìˆ˜ì´ë©´ ëœë‹¤. ì´ìœ ëŠ” ì•„ë˜ì˜ ê·¸ë¦¼ì²˜ëŸ¼ x, yì¶•ì— í‰í–‰í•œ ë‘ ë³€ ì‚¬ì´ì— ì¡´ì¬í•˜ëŠ” ë³€ì˜ ê°œìˆ˜ì— ë”°ë¼ nì´ ê²°ì •ë  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.  
![Center example image](https://user-images.githubusercontent.com/35067611/86225343-109e9080-bbc5-11ea-8ee3-9c39eeb798e1.jpg "Center"){: .center-image}  

### ì½”ë“œ  
~~~c++
#include <cstdio>
using namespace std;

int main() {

    int t, i, temp;

    scanf("%d", &t);

    for (i = 0; i < t; i++) {
        scanf("%d", &temp);
        if (temp % 4 == 0) printf("YES\n");
        else printf("NO\n");
    }


    return 0;
}
~~~

### B. AccurateLee  
time limit per test : 2 seconds  
memory limit per test : 256 megabytes  

Lee was cleaning his house for the party when he found a messy string under the carpets. Now he'd like to make it clean accurately and in a stylish way...  

The string ğ‘  he found is a binary string of length ğ‘› (i. e. string consists only of 0-s and 1-s).  

In one move he can choose two consecutive characters ğ‘ ğ‘– and ğ‘ ğ‘–+1, and if ğ‘ ğ‘– is 1 and ğ‘ ğ‘–+1 is 0, he can erase exactly one of them (he can choose which one to erase but he can't erase both characters simultaneously). The string shrinks after erasing.  

Lee can make an arbitrary number of moves (possibly zero) and he'd like to make the string ğ‘  as clean as possible. He thinks for two different strings ğ‘¥ and ğ‘¦, the shorter string is cleaner, and if they are the same length, then the lexicographically smaller string is cleaner.  

Now you should answer ğ‘¡ test cases: for the ğ‘–-th test case, print the cleanest possible string that Lee can get by doing some number of moves.  

Small reminder: if we have two strings ğ‘¥ and ğ‘¦ of the same length then ğ‘¥ is lexicographically smaller than ğ‘¦ if there is a position ğ‘– such that ğ‘¥1=ğ‘¦1, ğ‘¥2=ğ‘¦2,..., ğ‘¥ğ‘–âˆ’1=ğ‘¦ğ‘–âˆ’1 and ğ‘¥ğ‘–<ğ‘¦ğ‘–.  

Input  
The first line contains the integer ğ‘¡ (1â‰¤ğ‘¡â‰¤104) â€” the number of test cases.  

Next 2ğ‘¡ lines contain test cases â€” one per two lines.  

The first line of each test case contains the integer ğ‘› (1â‰¤ğ‘›â‰¤105) â€” the length of the string ğ‘ .  

The second line contains the binary string ğ‘ . The string ğ‘  is a string of length ğ‘› which consists only of zeroes and ones.  

It's guaranteed that sum of ğ‘› over test cases doesn't exceed 105.  

Output  
Print ğ‘¡ answers â€” one per test case.  

The answer to the ğ‘–-th test case is the cleanest string Lee can get after doing some number of moves (possibly zero).  

### ì ‘ê·¼  
leftmost 1ê³¼ rightmost 0ì˜ ìœ„ì¹˜ë¥¼ ì°¾ëŠ”ë‹¤. ì „ìë¥¼ left, í›„ìë¥¼ rightì´ë¼ê³  í•  ë•Œ string[left] .. string[right-1]ê¹Œì§€ì˜ ë¬¸ìì—´ì€ ì‚¬ë¼ì§„ë‹¤. ê·¸ ì´ìœ ëŠ” ë‹¤ìŒì˜ ì˜ˆì‹œë¥¼ ë³´ë©´ì„œ ì„¤ëª…í•˜ê² ë‹¤. í¸ì˜ìƒ ë¬¸ìì—´ì„ shrink í•˜ëŠ” ê³¼ì •ì€ ëª‡ëª‡ ë‹¨ê³„ë¥¼ ìƒëµí–ˆë‹¤.  
~~~
000 [101110111010] 011111
... [101110111010] ... -> ... [1010111010] ... -> ... [10101010] ... -> ... [1]0111 ...
~~~
ì´ì™€ ê°™ì´ ê´„í˜¸ ì•ˆì˜ ë¬¸ìì—´ì€ rightmost 0ë¥¼ ë§Œë‚˜ê²Œ ë˜ë©´ì„œ ëª¨ë‘ ì‚¬ë¼ì§ˆ ìˆ˜ ìˆë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ê´„í˜¸ ì•ˆì˜ ë¬¸ìì—´ì„ ì‚­ì œí•œ ë‚˜ë¨¸ì§€ë¥¼ ê·¸ëŒ€ë¡œ ì¨ì£¼ë©´ ì •ë‹µì´ë‹¤. ë‹¨, ì˜ˆì™¸ì²˜ë¦¬ë¥¼ í•´ì£¼ì–´ì•¼ í•  ê²ƒì´ left > rightì¸ ìƒí™©ì—ëŠ” ê¸°ì¡´ ë¬¸ìì—´ì„ ê·¸ëŒ€ë¡œ ì¶œë ¥í•´ì•¼ í•˜ëŠ”ë° ì´ ê²½ìš°ëŠ” ë¬¸ìì—´ ë‚´ì— "10"ìì²´ê°€ ì—†ê¸° ë•Œë¬¸ì´ë‹¤.  

### ì½”ë“œ  
~~~c++
#include <iostream>
#include <cstdio>
#include <string>
using namespace std;

int main() {

    int i, j, t, zero, one, onezero, len;
    scanf("%d", &t);

    for (i = 0; i < t; i++) {
        string s;
        int left, right;

        cin >> len;
        cin >> s;

        // find leftmost 1
        for (j = 0; j < len; j++) {
            if (s[j] == '1') break;
        }
        left = j;
        // find rightmost 0
        for (j = len - 1; j >= 0; j--) {
            if (s[j] == '0') break;
        }
        right = j;

        if (left > right) cout << s;
        else {
            for (j = 0; j < left; j++) printf("%c", s[j]);
            for (j = right; j < len; j++) printf("%c", s[j]);
        }
        printf("\n");

      }

    return 0;
}
~~~
